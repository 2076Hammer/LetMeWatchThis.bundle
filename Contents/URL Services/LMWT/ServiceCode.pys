import re, urlparse, cgi, urllib2from BeautifulSoup import BeautifulSoupUSER_AGENT = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_2) AppleWebKit/534.51.22 (KHTML, like Gecko) Version/5.1.1 Safari/534.51.22'	def MetadataObjectForURL(url): 	#Log('In MetadataObjectForURL for LMWT (' + url + ')')		# Return bare minimum. This is never shown to users.	video = VideoClipObject(		title = 'LMWT Redirect Page',		summary = 'LMWT Redirect Page',		thumb = None,	)		return videodef MediaObjectsForURL(url):	#Log('In MediaObjectsForURL for LMWT')		# Return bare minimum. Don't do any work until user actually 	# selects the video so that we don't run any more requests	# against LMWT than we have to.	ret = []	ret.append(		MediaObject(			parts = [PartObject(key=Callback(PlayVideo, url=url))],		)	)  	return ret@indirectdef PlayVideo(url):	c = ObjectContainer()		#Log('In PlayVideo for LMWT')		# Request LMWT redirect page.	#Log('Requesting ' + url)	request = urllib2.Request(url)	request.add_header('User-agent', USER_AGENT)		try:		response = urllib2.urlopen(request)	except urllib2.URLError, e:		Log('************** PROVIDER ERROR: Could not open page:' + url + ". Either LMWT or Provider may be down if LMWT issued a 302.")		return c	# Collect our eventual final location / url  to handle 302s and the like...	provider_url = response.geturl()		# If we're still on LMWT, read in frame loc, otherwise assume location is	# whatever url we've ended up on.	if (url == provider_url):		soup = BeautifulSoup(response.read())		final_url = str(soup.noframes.string)	else:		final_url = provider_url			# Use Plex's Service API to resolve the actual video URL for the provider we've	# been sent to.	provider_media_object = URLService.MediaObjectsForURL(final_url.decode('unicode_escape'))		# Return provider's media_object our own.	c.add(		VideoClipObject(			key = url,			items = provider_media_object,		)	)	return c