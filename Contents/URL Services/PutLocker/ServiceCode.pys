import re, urlparse, cgi, urllib, urllib2, cookielib, urlparsefrom BeautifulSoup import BeautifulSoupUSER_AGENT = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_2) AppleWebKit/534.51.22 (KHTML, like Gecko) Version/5.1.1 Safari/534.51.22'	def MetadataObjectForURL(url): 	#Log('In MetadataObjectForURL for PutLocker / Sockshare (' + url + ')')		video = VideoClipObject(		title = 'PutLocker / Sockshare Redirect Page',		summary = 'PutLocker / Sockshare Redirect Page',		thumb = None,	)		return videodef MediaObjectsForURL(url):	cj = cookielib.CookieJar()	opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cj))		# Request Provider page.	#Log('Requesting ' + url)	request = urllib2.Request(url)	request.add_header('User-agent', USER_AGENT)	response = opener.open(request)		# Read in location and content of PutLocker page.	provider_url = response.geturl()	soup = BeautifulSoup(response.read())	#Log(provider_url)		if (provider_url.endswith('?404')):		Log('************** PROVIDER ERROR: Video no longer available (404 Returned)')		return []		# Read in form info...	params = {}	params['hash'] = soup.find('input', {'name' : 'hash' })['value']	params['confirm'] = "Continue as Free User"	#Log(params)		# Submit form by re-requesting the same page.	#Log('Requesting ' + url)	request = urllib2.Request(url)	request.add_header('User-agent', USER_AGENT)	request.add_data(urllib.urlencode(params))	response = opener.open(request)		# Read in data from response.	content = response.read()	#Log(content)		# Look for playlist URL.	playlist_res = re.search("playlist: \'(.*?)\'", content)		if (playlist_res is None):		Log('************** PROVIDER ERROR: Playlist element not found on video page.')		return []		playlist = playlist_res.group(1)	#Log(playlist)		putlocker_host = urlparse.urlparse(url).netloc		# Fetch playlist	#Log('Requesting ' + "http://" + putlocker_host + playlist)	request = urllib2.Request("http://" + putlocker_host + playlist)	request.add_header('User-agent', USER_AGENT)	response = opener.open(request)		final = response.read()	#Log(final)		final_url = re.search("<media:content url=\"(.*?)\"", final).group(1)		# Need to manually follow final redirect so we can set some header in the video URL	# to somehow trick Plex / LibCurl.	if ('cdn' in final_url):			# Get final, final URL.		#Log('Requesting ' + final_url)		request = urllib2.Request(final_url)		request.add_header('User-agent', USER_AGENT)		request.add_header('Accept-Encoding','gzip, deflate')				# Use an URL opener which doesn't follow 302s.		opener_nofollow = urllib2.build_opener(NoRedirectHandler())		response = opener_nofollow.open(request)				final_url = response.headers['Location']			# Seems we manually need to set at least one header for some magic to happen with LibCurl.	# Looking at the request sent over the wire with and without the header being added seems	# to result in exactly the same request.... And yet, if we don't do this, the request	# without the added header hangs. <shrug>	final_url = final_url + "|Accept=*/*"	#Log(final_url)	ret = []	ret.append(		MediaObject(			parts = [PartObject(key=final_url)],		)	)  	return ret# urlib2 handler which doesn't automatically follow 302, but which instead returns the new# location.class NoRedirectHandler(urllib2.HTTPRedirectHandler):    def http_error_302(self, req, fp, code, msg, headers):        infourl = urllib.addinfourl(fp, headers, req.get_full_url())        infourl.status = code        infourl.code = code        return infourl